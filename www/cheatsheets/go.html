<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>go cheatsheet</title>
  <link href="s/main.css" rel="stylesheet" />
  <script src="s/main.js"></script>
</head>

<body onload="start()">
  <div class="breadcrumbs"><a href="/">Home</a> / <a href="index.html">cheatsheets</a> / go cheatsheet</div>
  <div class="edit">
      <a href="https://github.com/kjk/blog/blob/master/www/cheatsheets/other/go.md" >edit</a>
  </div>
  <div class="toc">
<b>Introduction</b>: <a href="#intro">Intro</a>, <a href="#go-cli-commands">Go CLI Commands</a>, <a href="#go-modules">Go Modules</a><br>
<b>Basic</b>: <a href="#basic-types">Basic Types</a>, <a href="#variables">Variables</a>, <a href="#operators">Operators</a>, <a href="#conditional-statements">Conditional Statements</a>, <a href="#loops">Loops</a>, <a href="#arrays">Arrays</a>, <a href="#functions">Functions</a><br>
<b>Advanced</b>: <a href="#structs">Structs</a>, <a href="#maps">Maps</a>, <a href="#pointers">Pointers</a>, <a href="#methods-and-interfaces">Methods and Interfaces</a>, <a href="#errors">Errors</a>, <a href="#testing">Testing</a>, <a href="#concurrency">Concurrency</a><br>
<b>Standard libs</b>: <a href="#fmt">fmt</a>, <a href="#os">os</a><br></div>


  <div id="start"></div>
  <div id="wrapped-content"></div>
<div id="content">
<h2 id="introduction">Introduction</h2>
<h3 id="intro">Intro</h3>
<p>Save this as <code>main.go</code>:</p>

<pre><code class="go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Println(<span class="hljs-string">&quot;Hello Gophers!&quot;</span>)
}
</code></pre>
<p>Run with: <code>go run main.go</code></p>
<h3 id="go-cli-commands">Go CLI Commands</h3>

<pre><code class="bash"><span class="hljs-comment"># Compile &amp; Run code</span>
$ go run [file.go]

<span class="hljs-comment"># Compile</span>
$ go build [file.go]
<span class="hljs-comment"># Running compiled file</span>
$ ./hello

<span class="hljs-comment"># Test packages</span>
$ go <span class="hljs-built_in">test</span> [folder]

<span class="hljs-comment"># Install packages/modules</span>
$ go install [package]

<span class="hljs-comment"># List installed packages/modules</span>
$ go list

<span class="hljs-comment"># Update packages/modules</span>
$ go fix

<span class="hljs-comment"># Format package sources</span>
$ go fmt

<span class="hljs-comment"># See package documentation</span>
$ go doc [package]

<span class="hljs-comment"># Add dependencies and install</span>
$ go get [module]

<span class="hljs-comment"># See Go environment variables</span>
$ go env

<span class="hljs-comment"># See version</span>
$ go version
</code></pre>
<h3 id="go-modules">Go Modules</h3>

<ul>
<li>Go projects are called <strong>modules</strong></li>
<li>Each module has one or more <strong>packages</strong></li>
<li>Files for a package are in a directory</li>
<li>A module needs at least one package, the <strong>main</strong></li>
<li>The package main needs a entry function called <strong>main</strong></li>
</ul>

<pre><code class="bash"><span class="hljs-comment"># Create Module</span>
$ go mod init [name]
</code></pre>
<p>Tip: By convention, modules names has the follow structure: <code>domain.com/user/module/package</code></p>
<p>Example: <code>github.com/spf13/cobra</code></p>
<h2 id="basic">Basic</h2>
<h3 id="basic-types">Basic Types</h3>

<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Set of Values</th>
<th style="text-align:center">Values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">array of characters</td>
<td style="text-align:center">needs to be inside &quot;&quot;</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">integers</td>
<td style="text-align:center">32 or 64 bit integer</td>
</tr>
<tr>
<td style="text-align:center">int8</td>
<td style="text-align:center">8-bit integers</td>
<td style="text-align:center">[ -128, 128 ]</td>
</tr>
<tr>
<td style="text-align:center">int16</td>
<td style="text-align:center">16-bit integers</td>
<td style="text-align:center">[ -32768, 32767]</td>
</tr>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">32-bit integers</td>
<td style="text-align:center">[ -2147483648, 2147483647]</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">64-bit integers</td>
<td style="text-align:center">[ -9223372036854775808, 9223372036854775807 ]</td>
</tr>
<tr>
<td style="text-align:center">uint8</td>
<td style="text-align:center">8-bit unsigned integers</td>
<td style="text-align:center">[ 0, 255 ]</td>
</tr>
<tr>
<td style="text-align:center">uint16</td>
<td style="text-align:center">16-bit unsigned integers</td>
<td style="text-align:center">[ 0, 65535 ]</td>
</tr>
<tr>
<td style="text-align:center">uint32</td>
<td style="text-align:center">32-bit unsigned integers</td>
<td style="text-align:center">[ 0, 4294967295 ]</td>
</tr>
<tr>
<td style="text-align:center">uint64</td>
<td style="text-align:center">64-bit unsigned integers</td>
<td style="text-align:center">[ 0, 18446744073709551615 ]</td>
</tr>
<tr>
<td style="text-align:center">float32</td>
<td style="text-align:center">32-bit float</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">float64</td>
<td style="text-align:center">64-bit float</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">complex64</td>
<td style="text-align:center">32-bit float with real and imaginary parts</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">complex128</td>
<td style="text-align:center">64-bit float with real and imaginary parts</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">sets of bits</td>
<td style="text-align:center">alias for uint8</td>
</tr>
<tr>
<td style="text-align:center">rune</td>
<td style="text-align:center">Unicode characters</td>
<td style="text-align:center">alias for int32</td>
</tr>
</tbody>
</table>
<h3 id="variables">Variables</h3>

<pre><code class="go"><span class="hljs-comment">// Declaration</span>
<span class="hljs-keyword">var</span> value <span class="hljs-keyword">int</span>

<span class="hljs-comment">// Initialization</span>
value = <span class="hljs-number">10</span>

<span class="hljs-comment">// Declaration + Initialization + Type inference</span>
<span class="hljs-keyword">var</span> isActive = <span class="hljs-literal">true</span>

<span class="hljs-comment">// Short declaration (only inside functions)</span>
text := <span class="hljs-string">&quot;Hello&quot;</span>

<span class="hljs-comment">// Multi declaration</span>
<span class="hljs-keyword">var</span> i, j, k = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>

<span class="hljs-comment">// Variable not initialized = Zero values</span>
<span class="hljs-comment">// Numeric: 0</span>
<span class="hljs-comment">// Boolean: false</span>
<span class="hljs-comment">// String: &quot;&quot;</span>
<span class="hljs-comment">// Special value: nil (same as null)</span>

<span class="hljs-keyword">var</span> number <span class="hljs-keyword">int</span> <span class="hljs-comment">// 0</span>
<span class="hljs-keyword">var</span> text <span class="hljs-keyword">string</span> <span class="hljs-comment">// &quot;&quot;</span>
<span class="hljs-keyword">var</span> boolean <span class="hljs-keyword">bool</span> <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Type conversions</span>
<span class="hljs-comment">// T(v) converts v to type T</span>

i := <span class="hljs-number">1.234</span> <span class="hljs-comment">// float</span>
<span class="hljs-keyword">int</span>(i) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// Constants</span>
<span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span>
</code></pre>
<h3 id="operators">Operators</h3>
<p><strong>Arithmetic Operators</strong>:</p>

<table>
<thead>
<tr>
<th style="text-align:center">Symbol</th>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Valid Types</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">Sum</td>
<td style="text-align:center">integers, floats, complex values, strings</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">Difference</td>
<td style="text-align:center">integers, floats, complex values</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">Product</td>
<td style="text-align:center">integers, floats, complex values</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">Quotient</td>
<td style="text-align:center">integers, floats, complex values</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">Remainder</td>
<td style="text-align:center">integers</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">Bitwise AND</td>
<td style="text-align:center">integers</td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td style="text-align:center">`</td>
<td style="text-align:center">Bitwise OR</td>
<td>integers</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">Bitwise XOR</td>
<td style="text-align:center">integers</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;^</code></td>
<td style="text-align:center">Bit clear (AND NOT)</td>
<td style="text-align:center">integers</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">Left shift</td>
<td style="text-align:center">integer &lt;&lt; unsigned integer</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">Right shift</td>
<td style="text-align:center">integer &gt;&gt; unsigned integer</td>
</tr>
</tbody>
</table>
<p><strong>Comparison Operators</strong>:</p>

<table>
<thead>
<tr>
<th style="text-align:center">Symbol</th>
<th style="text-align:center">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">Equal</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">Not equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">Less</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">Less or equal</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">Greater</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">Greater or equal</td>
</tr>
</tbody>
</table>
<p><strong>Logical Operators</strong>:</p>

<table>
<thead>
<tr>
<th style="text-align:center">Symbol</th>
<th style="text-align:center">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">Conditional AND</td>
</tr>
<tr>
<td style="text-align:center">`</td>
<td style="text-align:center"></td>
<td>`</td>
<td>Conditional OR</td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">NOT</td>
</tr>
</tbody>
</table>
<h3 id="conditional-statements">Conditional Statements</h3>

<pre><code class="go"><span class="hljs-comment">// If / Else</span>
i := <span class="hljs-number">1</span>

<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {
    <span class="hljs-comment">// Condition is True! i is greater than zero</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Condition is False! i is lower or equal to zero</span>
}

<span class="hljs-comment">// Else if</span>
i := <span class="hljs-number">1</span>

<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {
    <span class="hljs-comment">// Condition is True! i is greater than zero</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; <span class="hljs-number">2</span> {
    <span class="hljs-comment">// Condition is True! i greater than zero and lower than two</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">1</span> &amp;&amp; i &lt; <span class="hljs-number">4</span> {
    <span class="hljs-comment">// Condition is True! i greater than one and lower than four</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// None of the above conditions is True, so it falls here</span>
}

<span class="hljs-comment">// If with short statements</span>
i := <span class="hljs-number">2.567</span>

<span class="hljs-keyword">if</span> j := <span class="hljs-keyword">int</span>(i); j == <span class="hljs-number">2</span> {
    <span class="hljs-comment">// Condition is True! j, the integer value of i, is equal to two</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Condition is False! j, the integer value of i, is not equal to two</span>
}

<span class="hljs-comment">// Switch</span>
text := <span class="hljs-string">&#x27;hey&#x27;</span>

<span class="hljs-keyword">switch</span> text {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hey&#x27;</span>:
        <span class="hljs-comment">// &#x27;Hello!&#x27;</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;bye&#x27;</span>:
        <span class="hljs-comment">// &#x27;Byee&#x27;</span>
    <span class="hljs-keyword">default</span>:
        <span class="hljs-comment">// &#x27;Ok&#x27;</span>
}

<span class="hljs-comment">// Switch without condition</span>
value := <span class="hljs-number">5</span>

<span class="hljs-keyword">switch</span> {
    <span class="hljs-keyword">case</span> value &lt; <span class="hljs-number">2</span>:
        <span class="hljs-comment">// &#x27;Hello!&#x27;</span>
    <span class="hljs-keyword">case</span> value &gt;= <span class="hljs-number">2</span> &amp;&amp; value &lt; <span class="hljs-number">6</span>:
        <span class="hljs-comment">// &#x27;Byee&#x27;</span>
    <span class="hljs-keyword">default</span>:
        <span class="hljs-comment">// &#x27;Ok&#x27;</span>
}
</code></pre>
<h3 id="loops">Loops</h3>

<pre><code class="go"><span class="hljs-comment">// Golang only has the for loop</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {
    <span class="hljs-comment">// i</span>
}

<span class="hljs-comment">// The first and third parameters are ommitable</span>
<span class="hljs-comment">// For as a while</span>
i := <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> {
    i++
}

<span class="hljs-comment">// Forever loop</span>
<span class="hljs-keyword">for</span> {

}
</code></pre>
<h3 id="arrays">Arrays</h3>

<pre><code class="go"><span class="hljs-comment">// Declaration with specified size</span>
<span class="hljs-keyword">var</span> array [<span class="hljs-number">3</span>]<span class="hljs-keyword">string</span>
array[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Hello&quot;</span>
array[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Golang&quot;</span>
array[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;World&quot;</span>

<span class="hljs-comment">// Declaration and Initialization</span>
values := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}

<span class="hljs-comment">// Slices: A subarray that acts as a reference of an array</span>
<span class="hljs-comment">// Determining min and max</span>
values[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">// {2, 3, 4}</span>

<span class="hljs-comment">// Determining only max will use min = 0</span>
values[:<span class="hljs-number">2</span>] <span class="hljs-comment">// {1, 2, 3}</span>

<span class="hljs-comment">// Determining only min will use max = last element</span>
values[<span class="hljs-number">3</span>:] <span class="hljs-comment">// {3, 4}</span>

<span class="hljs-comment">// Length: number of elements that a slice contains</span>
<span class="hljs-built_in">len</span>(values) <span class="hljs-comment">// 5</span>

<span class="hljs-comment">// Capacity: number of elements that a slice can contain</span>
values = values[:<span class="hljs-number">1</span>]
<span class="hljs-built_in">len</span>(values) <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">cap</span>(values) <span class="hljs-comment">// 5</span>

<span class="hljs-comment">// Slice literal</span>
slice := []<span class="hljs-keyword">bool</span>{<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>}

<span class="hljs-comment">// make function: create a slice with length and capacity</span>
slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// make(type, len, cap)</span>

<span class="hljs-comment">// Append new element to slice</span>
slice := []<span class="hljs-keyword">int</span>{ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> }
slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">3</span>)
slice <span class="hljs-comment">// { 1, 2, 3 }</span>
slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
slice <span class="hljs-comment">// { 1, 2, 3, 3, 2, 1 }</span>

<span class="hljs-comment">// For range: iterate over a slice</span>
slice := <span class="hljs-keyword">string</span>[<span class="hljs-string">&quot;W&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>]

<span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> slice {
    i <span class="hljs-comment">// 0, then 1, then 2</span>
    value <span class="hljs-comment">// &quot;W&quot;, then &quot;o&quot;, then &quot;w&quot;</span>
}

<span class="hljs-comment">// Skip index or value</span>

<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> slice {
    i <span class="hljs-comment">// 0, then 1, then 2</span>
}

<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> slice {
   value <span class="hljs-comment">// &quot;W&quot;, then &quot;o&quot;, then &quot;w&quot;</span>
}
</code></pre>
<h3 id="functions">Functions</h3>

<pre><code class="go"><span class="hljs-comment">// Functions acts as a scoped block of code</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Hello World!</span>
}
sayHello() <span class="hljs-comment">// Hello World!</span>

<span class="hljs-comment">// Functions can take zero or more parameters, as so return zero or more parameters</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> x + y
}
sum(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) <span class="hljs-comment">// 10</span>

<span class="hljs-comment">// Returned values can be named and be used inside the function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doubleAndTriple</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(double, triple <span class="hljs-keyword">int</span>)</span></span> {
    double = x * <span class="hljs-number">2</span>
    triple = x * <span class="hljs-number">3</span>
    <span class="hljs-keyword">return</span>
}
d, t := doubleAndTriple(<span class="hljs-number">5</span>)
<span class="hljs-comment">// d = 10</span>
<span class="hljs-comment">// t = 15</span>

<span class="hljs-comment">// Skipping one of the returned values</span>
_, t := doubleAndTriple(<span class="hljs-number">3</span>)
<span class="hljs-comment">// t = 9</span>

<span class="hljs-comment">// Functions can defer commands. Defered commands are</span>
<span class="hljs-comment">// runned in a stack order after the execution and</span>
<span class="hljs-comment">// returning of a function</span>
<span class="hljs-keyword">var</span> aux = <span class="hljs-number">0</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchValuesAndDouble</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> {
    aux = x
    <span class="hljs-keyword">defer</span> aux = <span class="hljs-number">0</span> <span class="hljs-comment">// cleaning variable to post use</span>
    x = y * <span class="hljs-number">2</span>
    y = aux * <span class="hljs-number">2</span>
}

a, b = <span class="hljs-number">2</span>, <span class="hljs-number">5</span>
switchValuesAndDouble(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)

<span class="hljs-comment">// a = 10</span>
<span class="hljs-comment">// b = 4</span>
<span class="hljs-comment">// aux = 0</span>

<span class="hljs-comment">// Functions can be handled as values and be anonymous functions</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>) <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> fn(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> x + y
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mult</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> x * y
}

calc(sum) <span class="hljs-comment">// 8</span>
calc(mult) <span class="hljs-comment">// 12</span>
calc(
    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
        <span class="hljs-keyword">return</span> x / y
    }
) <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// Function closures: a function that returns a function</span>
<span class="hljs-comment">// that remembers the original context</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    value := <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
        value += x
        <span class="hljs-keyword">return</span> value
    }
}

calculator := calc()
calculator(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3</span>
calculator(<span class="hljs-number">45</span>) <span class="hljs-comment">// 48</span>
calculator(<span class="hljs-number">12</span>) <span class="hljs-comment">// 60</span>
</code></pre>
<h2 id="advanced">Advanced</h2>
<h3 id="structs">Structs</h3>
<p>Structs are a way to arrange data in specific formats.</p>

<pre><code class="go"><span class="hljs-comment">// Declaring a struct</span>
<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-keyword">string</span>
    Age <span class="hljs-keyword">int</span>
}

<span class="hljs-comment">// Initializing</span>
person := Person{<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">34</span>}
person.Name <span class="hljs-comment">// &quot;John&quot;</span>
person.Age <span class="hljs-comment">// 34</span>

person2 := Person{Age: <span class="hljs-number">20</span>}
person2.Name <span class="hljs-comment">// &quot;&quot;</span>
person2.Age <span class="hljs-comment">// 20</span>

person3 := Person{}
person3.Name <span class="hljs-comment">// &quot;&quot;</span>
person3.Age <span class="hljs-comment">// 0</span>
</code></pre>
<h3 id="maps">Maps</h3>
<p>Maps are data structures that holds values assigneds to a key.</p>

<pre><code class="go"><span class="hljs-comment">// Declaring a map</span>
<span class="hljs-keyword">var</span> cities <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>

<span class="hljs-comment">// Initializing</span>
cities = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)
cities <span class="hljs-comment">// nil</span>

<span class="hljs-comment">// Insert</span>
cities[<span class="hljs-string">&quot;NY&quot;</span>] = <span class="hljs-string">&quot;EUA&quot;</span>

<span class="hljs-comment">// Retrieve</span>
newYork = cities[<span class="hljs-string">&quot;NY&quot;</span>]
newYork <span class="hljs-comment">// &quot;EUA&quot;</span>

<span class="hljs-comment">// Delete</span>
<span class="hljs-built_in">delete</span>(cities, <span class="hljs-string">&quot;NY&quot;</span>)

<span class="hljs-comment">// Check if a key is setted</span>
value, ok := cities[<span class="hljs-string">&quot;NY&quot;</span>]
ok <span class="hljs-comment">// false</span>
value <span class="hljs-comment">// &quot;&quot;</span>
</code></pre>
<h3 id="pointers">Pointers</h3>
<p>Pointers are a direct reference to a memory address that some variable or value is being stored.</p>

<pre><code class="go"><span class="hljs-comment">// Pointers has *T type</span>
<span class="hljs-keyword">var</span> value <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> pointer *<span class="hljs-keyword">int</span>

<span class="hljs-comment">// Point to a variable memory address with &amp;</span>
value = <span class="hljs-number">3</span>
pointer = &amp;value

pointer <span class="hljs-comment">// 3</span>
pointer = <span class="hljs-number">20</span>
pointer <span class="hljs-comment">// 20</span>
pointer += <span class="hljs-number">5</span>
pointer <span class="hljs-comment">// 25</span>

<span class="hljs-comment">// Pointers to structs can access the attributes</span>
<span class="hljs-keyword">type</span> Struct <span class="hljs-keyword">struct</span> {
    X <span class="hljs-keyword">int</span>
}

s := Struct{<span class="hljs-number">3</span>}
pointer := &amp;s

s.X <span class="hljs-comment">// 3</span>
</code></pre>
<p>Obs: Unlike C, Go doesn&#39;t have pointer arithmetics.</p>
<h3 id="methods-and-interfaces">Methods and Interfaces</h3>
<p>Go doesn&#39;t have classes. But you can implement methods, interfaces and almost everything contained in OOP, but in what gophers call &quot;Go Way&quot;</p>

<pre><code class="go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-keyword">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog *Dog)</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> dog.Name + <span class="hljs-string">&quot; is barking!&quot;</span>
}

dog := Dog{<span class="hljs-string">&quot;Rex&quot;</span>}
dog.bark() <span class="hljs-comment">// Rex is barking!</span>
</code></pre>
<p>Interfaces are implicitly implemented. You don&#39;t need to inform that your struct are correctly implementing a interface if it already has all methods with the same name of the interface.
All structs implement the <code>interface{}</code> interface. This empty interface means the same as <code>any</code>.</p>

<pre><code class="go"><span class="hljs-comment">// Car implements Vehicle interface</span>
<span class="hljs-keyword">type</span> Vehicle <span class="hljs-keyword">interface</span> {
    Accelerate()
}

<span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> {

}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(car *Car)</span> <span class="hljs-title">Accelerate</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car is moving on ground&quot;</span>
}
</code></pre>
<h3 id="errors">Errors</h3>
<p>Go doesn&#39;t support <code>throw</code>, <code>try</code>, <code>catch</code> and other common error handling structures. Here, we use <code>error</code> package to build possible errors as a returning parameter in functions</p>

<pre><code class="go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span>

<span class="hljs-comment">// Function that contain a logic that can cause a possible exception flow </span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstLetter</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> {
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(text) &lt; <span class="hljs-number">1</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;Parameter text is empty&quot;</span>)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(text[<span class="hljs-number">0</span>]), <span class="hljs-literal">nil</span>
}

a, errorA := firstLetter(<span class="hljs-string">&quot;Wow&quot;</span>)
a <span class="hljs-comment">// &quot;W&quot;</span>
errorA <span class="hljs-comment">// nil</span>

b, errorB := firstLetter(<span class="hljs-string">&quot;&quot;</span>)
b <span class="hljs-comment">// nil</span>
errorB <span class="hljs-comment">// Error(&quot;Parameter text is empty&quot;)</span>
</code></pre>
<h3 id="testing">Testing</h3>
<p>Go has a built-in library to unit testing. In a separate file you insert tests for functionalities of a file and run <code>go test package</code> to run all tests of the actual package or <code>go test path</code> to run a specific test file.</p>

<pre><code class="go"><span class="hljs-comment">// main.go</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> x + y
}

<span class="hljs-comment">// main_test.go</span>
<span class="hljs-keyword">import</span> ( 
    <span class="hljs-string">&quot;testing&quot;</span>
    <span class="hljs-string">&quot;reflect&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSum</span><span class="hljs-params">(t *testing.T)</span></span> {
    x, y := <span class="hljs-number">2</span>, <span class="hljs-number">4</span>
    expected := <span class="hljs-number">2</span> + <span class="hljs-number">4</span>

    <span class="hljs-keyword">if</span> !reflect.DeepEqual(sum(x, y), expected) {
        t.Fatalf(<span class="hljs-string">&quot;Function Sum not working as expected&quot;</span>)
    }
}
</code></pre>
<h3 id="concurrency">Concurrency</h3>
<p>One of the main parts that make Go attractive is its form to handle with concurrency. Different than parallelism, where tasks can be separated in many cores that the machine processor have, in concurrency we have routines that are more lightweight than threads and can run asynchronously, with memory sharing and in a single core.</p>

<pre><code class="go"><span class="hljs-comment">// Consider a common function, but that function can delay itself because some processing</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(from <span class="hljs-keyword">string</span>)</span></span> {
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ {
        fmt.Printf(<span class="hljs-string">&quot;%s : %d\n&quot;</span>, from, i)
    }
}

<span class="hljs-comment">// In a blocking way...</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    show(<span class="hljs-string">&quot;blocking1&quot;</span>)
    show(<span class="hljs-string">&quot;blocking2&quot;</span>)

    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)
}
<span class="hljs-comment">/*  blocking1: 0
    blocking1: 1
    blocking1: 2
    blocking2: 0
    blocking2: 1
    blocking2: 2
    done 
*/</span>

<span class="hljs-comment">// Go routines are a function (either declared previously or anonymous) called with the keyword go</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;routine1&quot;</span>)
    <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;routine2&quot;</span>)

    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        fmt.Println(<span class="hljs-string">&quot;going&quot;</span>)
    }()

    time.Sleep(time.Second)

    fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)
}

<span class="hljs-comment">/*  Obs: The result will depends of what processes first
    routine2: 0
    routine2: 1
    routine2: 2
    going
    routine1: 0
    routine1: 1
    routine1: 2
    done
*/</span>

<span class="hljs-comment">// Routines can share data with channels</span>
<span class="hljs-comment">// Channels are queues that store data between multiple routines</span>
msgs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)

<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(channel <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> {
    channel &lt;- <span class="hljs-string">&quot;ping&quot;</span>
}(msgs)

<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(channel <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> {
    channel &lt;- <span class="hljs-string">&quot;pong&quot;</span>
}(msgs)

fmt.Println(&lt;-msgs) <span class="hljs-comment">// pong</span>
fmt.Println(&lt;-msgs) <span class="hljs-comment">// ping</span>

<span class="hljs-comment">// Channels can be bufferized. Buffered channels will accept a limited number of values and when someone try to put belong their limit, it will throw and error</span>
numbers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)

msgs&lt;<span class="hljs-number">-0</span>
msgs&lt;<span class="hljs-number">-1</span>
msgs&lt;<span class="hljs-number">-2</span>

<span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>

<span class="hljs-comment">// Channels can be passed as parameter where the routine can only send or receive</span>
numbers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)

<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sender <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> {
    sender &lt;- <span class="hljs-number">10</span>
}(numbers)

<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(receiver &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> {
    fmt.Println(&lt;-receiver) <span class="hljs-comment">// 10</span>
}(numbers)

time.Sleep(time.Second)

<span class="hljs-comment">// When working with multiple channels, the select can provide a control to execute code accordingly of what channel has bring a message</span>
c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)
c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)

<span class="hljs-keyword">select</span> {
<span class="hljs-keyword">case</span> msg1 := &lt;-c1:
    fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg1)
<span class="hljs-keyword">case</span> msg2 := &lt;-c2:
    fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg2)
<span class="hljs-keyword">default</span>:
    fmt.Println(<span class="hljs-string">&quot;no messages&quot;</span>)
}

<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
    time.Sleep(<span class="hljs-number">1</span> * time.Second)
    c1 &lt;- <span class="hljs-string">&quot;channel1 : one&quot;</span>
}()
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
    time.Sleep(<span class="hljs-number">2</span> * time.Second)
    c2 &lt;- <span class="hljs-string">&quot;channel2 : one&quot;</span>
}()

<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ {
    <span class="hljs-keyword">select</span> {
    <span class="hljs-keyword">case</span> msg1 := &lt;-c1:
        fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg1)
    <span class="hljs-keyword">case</span> msg2 := &lt;-c2:
        fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg2)
    }
}

<span class="hljs-comment">/*
    no messages
    received channel1: one
    received channel2: one
*/</span>

<span class="hljs-comment">// Channels can be closed and iterated</span>
channel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)

<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ {
    channel &lt;- i
}

<span class="hljs-built_in">close</span>(channel)

<span class="hljs-keyword">for</span> value := <span class="hljs-keyword">range</span> channel {
    fmt.Println(value)
}

<span class="hljs-comment">/*
    0
    1
    2
    3
    4
*/</span>
</code></pre>
<h2 id="standard-libs">Standard libs</h2>
<h3 id="fmt">fmt</h3>
<p><strong>Important</strong>: <a href="https://pkg.go.dev/fmt#Printf">Printf</a>, <a href="https://pkg.go.dev/fmt#MErrorf">Errorf</a>, <a href="https://pkg.go.dev/fmt#Sprintf">Sprintf</a>, <a href="https://pkg.go.dev/fmt">official docs</a></p>

<pre><code class="go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

fmt.Printf(<span class="hljs-string">&quot;%s is %d years old\n&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">32</span>) <span class="hljs-comment">// Print with formatting</span>
fmt.Errorf(<span class="hljs-string">&quot;User %d not found&quot;</span>, <span class="hljs-number">123</span>) <span class="hljs-comment">// Print a formatted error</span>
s := fmt.Sprintf(<span class="hljs-string">&quot;Boolean: %v\n&quot;</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// format to a string</span>
</code></pre>
<h3 id="os">os</h3>
<p><strong>Important</strong>: <a href="https://pkg.go.dev/os#Chdir">Chdir</a>, <a href="https://pkg.go.dev/os#Mkdir">Mkdir</a>, <a href="https://pkg.go.dev/os#MkdirAll">MkdirAll</a>, <a href="https://pkg.go.dev/os#ReadFile">ReadFile</a>, <a href="https://pkg.go.dev/os#Remove">Remove</a>, <a href="https://pkg.go.dev/os#RemoveAll">RemoveAll</a>, <a href="https://pkg.go.dev/os#Rename">Rename</a>, <a href="https://pkg.go.dev/os#WriteFile">WriteFile</a>, <a href="https://pkg.go.dev/os">official docs</a></p>

<pre><code class="go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span>

err := os.Mkdir(<span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-number">0755</span>)
err = os.RemoveAll(<span class="hljs-string">&quot;dir&quot;</span>)

d := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;my data&quot;</span>)
err = os.WriteFile(<span class="hljs-string">&quot;file.txt&quot;</span>, d, <span class="hljs-number">0644</span>)

d, err = os.ReadFile(<span class="hljs-string">&quot;file.txt&quot;</span>)
fmt.Printf(<span class="hljs-string">&quot;Content of file.txt:\n%s\n&quot;</span>, <span class="hljs-keyword">string</span>(d))
</code></pre>

</div>
</body>  
</html>