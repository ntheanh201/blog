<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Nopt cheatsheet</title>
  <link href="s/main.css" rel="stylesheet" />
  <script src="s/main.js"></script>
</head>

<body onload="start()">
  <div class="breadcrumbs"><a href="/">Home</a> / <a href="index.html">cheatsheets</a> / Nopt cheatsheet</div>
  <div class="edit">
      <a href="https://github.com/kjk/blog/blob/master/www/cheatsheets/devhints\nopt.md" >edit</a>
  </div>
  <div class="toc">
<b>Basics</b>: <a href="#intro">Intro</a>, <a href="#usage">USAGE</a>, <a href="#types">Types</a>, <a href="#error-handling">Error Handling</a>, <a href="#abbreviations">Abbreviations</a>, <a href="#shorthands">Shorthands</a>, <a href="#the-rest-of-the-args">The Rest of the args</a>, <a href="#slicing">Slicing</a><br></div>


  <div id="start"></div>
  <div id="wrapped-content"></div>
<div id="content">
<h2 id="basics">Basics</h2>
<h3 id="intro">Intro</h3>
<p><a href="https://www.npmjs.org/package/nopt">noopt</a> is a Node.js library for 
parsing command-line arguments.</p>
<h3 id="usage">USAGE</h3>

<pre><code class="javascript"><span class="hljs-comment">// my-program.js</span>
<span class="hljs-keyword">var</span> nopt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;nopt&quot;</span>)
  , <span class="hljs-title class_">Stream</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;stream&quot;</span>).<span class="hljs-property">Stream</span>
  , path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>)
  , knownOpts = { <span class="hljs-string">&quot;foo&quot;</span> : [<span class="hljs-title class_">String</span>, <span class="hljs-literal">null</span>]
                , <span class="hljs-string">&quot;bar&quot;</span> : [<span class="hljs-title class_">Stream</span>, <span class="hljs-title class_">Number</span>]
                , <span class="hljs-string">&quot;baz&quot;</span> : path
                , <span class="hljs-string">&quot;bloo&quot;</span> : [ <span class="hljs-string">&quot;big&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>, <span class="hljs-string">&quot;small&quot;</span> ]
                , <span class="hljs-string">&quot;flag&quot;</span> : <span class="hljs-title class_">Boolean</span>
                , <span class="hljs-string">&quot;pick&quot;</span> : <span class="hljs-title class_">Boolean</span>
                , <span class="hljs-string">&quot;many1&quot;</span> : [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Array</span>]
                , <span class="hljs-string">&quot;many2&quot;</span> : [path, <span class="hljs-title class_">Array</span>]
                }
  , shortHands = { <span class="hljs-string">&quot;foofoo&quot;</span> : [<span class="hljs-string">&quot;--foo&quot;</span>, <span class="hljs-string">&quot;Mr. Foo&quot;</span>]
                 , <span class="hljs-string">&quot;b7&quot;</span> : [<span class="hljs-string">&quot;--bar&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>]
                 , <span class="hljs-string">&quot;m&quot;</span> : [<span class="hljs-string">&quot;--bloo&quot;</span>, <span class="hljs-string">&quot;medium&quot;</span>]
                 , <span class="hljs-string">&quot;p&quot;</span> : [<span class="hljs-string">&quot;--pick&quot;</span>]
                 , <span class="hljs-string">&quot;f&quot;</span> : [<span class="hljs-string">&quot;--flag&quot;</span>]
                 }
             <span class="hljs-comment">// everything is optional.</span>
             <span class="hljs-comment">// knownOpts and shorthands default to {}</span>
             <span class="hljs-comment">// arg list defaults to process.argv</span>
             <span class="hljs-comment">// slice defaults to 2</span>
  , parsed = <span class="hljs-title function_">nopt</span>(knownOpts, shortHands, process.<span class="hljs-property">argv</span>, <span class="hljs-number">2</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed)
</code></pre>
<p>This would give you support for any of the following:</p>

<pre><code class="console"><span class="hljs-meta">$ </span><span class="language-bash">node my-program.js --foo <span class="hljs-string">&quot;blerp&quot;</span> --no-flag</span>
{ &quot;foo&quot; : &quot;blerp&quot;, &quot;flag&quot; : false }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js ---bar 7 --foo <span class="hljs-string">&quot;Mr. Hand&quot;</span> --flag</span>
{ bar: 7, foo: &quot;Mr. Hand&quot;, flag: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --foo <span class="hljs-string">&quot;blerp&quot;</span> -f -----p</span>
{ foo: &quot;blerp&quot;, flag: true, pick: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js -fp --foofoo</span>
{ foo: &quot;Mr. Foo&quot;, flag: true, pick: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --foofoo -- -fp  <span class="hljs-comment"># -- stops the flag parsing.</span></span>
{ foo: &quot;Mr. Foo&quot;, argv: { remain: [&quot;-fp&quot;] } }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --blatzk -fp <span class="hljs-comment"># unknown opts are ok.</span></span>
{ blatzk: true, flag: true, pick: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --blatzk=1000 -fp <span class="hljs-comment"># but you need to use = if they have a value</span></span>
{ blatzk: 1000, flag: true, pick: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --no-blatzk -fp <span class="hljs-comment"># unless they start with &quot;no-&quot;</span></span>
{ blatzk: false, flag: true, pick: true }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --baz b/a/z <span class="hljs-comment"># known paths are resolved.</span></span>
{ baz: &quot;/Users/isaacs/b/a/z&quot; }
<span class="hljs-meta">
# </span><span class="language-bash"><span class="hljs-keyword">if</span> Array is one of the types, <span class="hljs-keyword">then</span> it can take many</span>
<span class="hljs-meta"># </span><span class="language-bash">values, and will always be an array.  The other types provided</span>
<span class="hljs-meta"># </span><span class="language-bash">specify what types are allowed <span class="hljs-keyword">in</span> the list.</span>
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --many1 5 --many1 null --many1 foo</span>
{ many1: [&quot;5&quot;, &quot;null&quot;, &quot;foo&quot;] }
<span class="hljs-meta">
$ </span><span class="language-bash">node my-program.js --many2 foo --many2 bar</span>
{ many2: [&quot;/path/to/foo&quot;, &quot;path/to/bar&quot;] }
</code></pre>
<p>Read the tests at the bottom of <code>lib/nopt.js</code> for more examples of
what this puppy can do.</p>
<h3 id="types">Types</h3>
<p>The following types are supported, and defined on <code>nopt.typeDefs</code></p>

<ul>
<li>String: A normal string.  No parsing is done.</li>
<li>path: A file system path.  Gets resolved against cwd if not absolute.</li>
<li>url: A url.  If it doesn&#39;t parse, it isn&#39;t accepted.</li>
<li>Number: Must be numeric.</li>
<li>Date: Must parse as a date. If it does, and <code>Date</code> is one of the options,
then it will return a Date object, not a string.</li>
<li>Boolean: Must be either <code>true</code> or <code>false</code>.  If an option is a boolean,
then it does not need a value, and its presence will imply <code>true</code> as
the value.  To negate boolean flags, do <code>--no-whatever</code> or <code>--whatever
false</code></li>
<li>NaN: Means that the option is strictly not allowed.  Any value will
fail.</li>
<li>Stream: An object matching the &quot;Stream&quot; class in node.  Valuable
for use when validating programmatically.  (npm uses this to let you
supply any WriteStream on the <code>outfd</code> and <code>logfd</code> config options.)</li>
<li>Array: If <code>Array</code> is specified as one of the types, then the value
will be parsed as a list of options.  This means that multiple values
can be specified, and that the value will always be an array.</li>
</ul>
<p>If a type is an array of values not on this list, then those are
considered valid values.  For instance, in the example above, the
<code>--bloo</code> option can only be one of <code>&quot;big&quot;</code>, <code>&quot;medium&quot;</code>, or <code>&quot;small&quot;</code>,
and any other value will be rejected.</p>
<p>When parsing unknown fields, <code>&quot;true&quot;</code>, <code>&quot;false&quot;</code>, and <code>&quot;null&quot;</code> will be
interpreted as their JavaScript equivalents.</p>
<p>You can also mix types and values, or multiple types, in a list.  For
instance <code>{ blah: [Number, null] }</code> would allow a value to be set to
either a Number or null.  When types are ordered, this implies a
preference, and the first type that can be used to properly interpret
the value will be used.</p>
<p>To define a new type, add it to <code>nopt.typeDefs</code>.  Each item in that
hash is an object with a <code>type</code> member and a <code>validate</code> method.  The
<code>type</code> member is an object that matches what goes in the type list.  The
<code>validate</code> method is a function that gets called with <code>validate(data,
key, val)</code>.  Validate methods should assign <code>data[key]</code> to the valid
value of <code>val</code> if it can be handled properly, or return boolean
<code>false</code> if it cannot.</p>
<p>You can also call <code>nopt.clean(data, types, typeDefs)</code> to clean up a
config object and remove its invalid properties.</p>
<h3 id="error-handling">Error Handling</h3>
<p>By default, nopt outputs a warning to standard error when invalid values for
known options are found.  You can change this behavior by assigning a method
to <code>nopt.invalidHandler</code>.  This method will be called with
the offending <code>nopt.invalidHandler(key, val, types)</code>.</p>
<p>If no <code>nopt.invalidHandler</code> is assigned, then it will console.error
its whining.  If it is assigned to boolean <code>false</code> then the warning is
suppressed.</p>
<h3 id="abbreviations">Abbreviations</h3>
<p>Yes, they are supported.  If you define options like this:</p>

<pre><code class="javascript">{ <span class="hljs-string">&quot;foolhardyelephants&quot;</span> : <span class="hljs-title class_">Boolean</span>
, <span class="hljs-string">&quot;pileofmonkeys&quot;</span> : <span class="hljs-title class_">Boolean</span> }
</code></pre>
<p>Then this will work:</p>

<pre><code class="bash">node program.js --foolhar --pil
node program.js --no-f --pileofmon
<span class="hljs-comment"># etc.</span>
</code></pre>
<h3 id="shorthands">Shorthands</h3>
<p>Shorthands are a hash of shorter option names to a snippet of args that
they expand to.</p>
<p>If multiple one-character shorthands are all combined, and the
combination does not unambiguously match any other option or shorthand,
then they will be broken up into their constituent parts.  For example:</p>

<pre><code class="json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;s&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;--loglevel&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;silent&quot;</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;g&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--global&quot;</span>
<span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;f&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--force&quot;</span>
<span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;p&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--parseable&quot;</span>
<span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;l&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--long&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>

<pre><code class="bash">npm ls -sgflp
<span class="hljs-comment"># just like doing this:</span>
npm ls --loglevel silent --global --force --long --parseable
</code></pre>
<h3 id="the-rest-of-the-args">The Rest of the args</h3>
<p>The config object returned by nopt is given a special member called
<code>argv</code>, which is an object with the following fields:</p>

<ul>
<li><code>remain</code>: The remaining args after all the parsing has occurred.</li>
<li><code>original</code>: The args as they originally appeared.</li>
<li><code>cooked</code>: The args after flags and shorthands are expanded.</li>
</ul>
<h3 id="slicing">Slicing</h3>
<p>Node programs are called with more or less the exact argv as it appears
in C land, after the v8 and node-specific options have been plucked off.
As such, <code>argv[0]</code> is always <code>node</code> and <code>argv[1]</code> is always the
JavaScript program being run.</p>
<p>That&#39;s usually not very useful to you.  So they&#39;re sliced off by
default.  If you want them, then you can pass in <code>0</code> as the last
argument, or any other number that you&#39;d like to slice off the start of
the list.</p>

</div>
</body>  
</html>