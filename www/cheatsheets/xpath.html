<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Xpath cheatsheet</title>
  <link href="s/main.css" rel="stylesheet" />
  <script src="s/main.js"></script>
</head>

<body onload="start()">
  <div class="breadcrumbs"><a href="/">Home</a> / <a href="index.html">cheatsheets</a> / Xpath cheatsheet</div>
  <div class="edit">
      <a href="https://github.com/kjk/blog/blob/master/www/cheatsheets/devhints\xpath.md" >edit</a>
  </div>
  <div class="toc">
<b>Testing</b>: <a href="#xpath-test-bed">Xpath test bed</a>, <a href="#browser-console">Browser console</a><br>
<b>Selectors</b>: <a href="#descendant-selectors">Descendant selectors</a>, <a href="#attribute-selectors">Attribute selectors</a>, <a href="#order-selectors">Order selectors</a>, <a href="#siblings">Siblings</a>, <a href="#jquery">jQuery</a>, <a href="#other-things">Other things</a>, <a href="#class-check">Class check</a><br>
<b>Expressions</b>: <a href="#steps-and-axes">Steps and axes</a>, <a href="#prefixes">Prefixes</a>, <a href="#axes">Axes</a>, <a href="#steps">Steps</a><br>
<b>Predicates</b>: <a href="#predicates">Predicates</a>, <a href="#operators">Operators</a>, <a href="#using-nodes">Using nodes</a>, <a href="#indexing">Indexing</a>, <a href="#chaining-order">Chaining order</a>, <a href="#nesting-predicates">Nesting predicates</a><br>
<b>Functions</b>: <a href="#node-functions">Node functions</a>, <a href="#boolean-functions">Boolean functions</a>, <a href="#string-functions">String functions</a>, <a href="#type-conversion">Type conversion</a><br>
<b>Axes</b>: <a href="#using-axes">Using axes</a>, <a href="#child-axis">Child axis</a>, <a href="#descendant-or-self-axis">Descendant-or-self axis</a>, <a href="#other-axes">Other axes</a>, <a href="#unions">Unions</a><br>
<b>More examples</b>: <a href="#examples">Examples</a>, <a href="#find-a-parent">Find a parent</a>, <a href="#closest">Closest</a>, <a href="#attributes">Attributes</a><br>
<a href="#references">References</a><br></div>


  <div id="start"></div>
  <div id="wrapped-content"></div>
<div id="content">
<h2 id="testing">Testing</h2>
<h3 id="xpath-test-bed">Xpath test bed</h3>
<p>Test queries in the Xpath test bed:</p>

<ul>
<li><a href="http://www.whitebeam.org/library/guide/TechNotes/xpathtestbed.rhtm">Xpath test bed</a> <em>(whitebeam.org)</em></li>
</ul>
<h3 id="browser-console">Browser console</h3>

<pre><code class="js">$x(<span class="hljs-string">&quot;//div&quot;</span>)
</code></pre>
<p>Works in Firefox and Chrome.</p>
<h2 id="selectors">Selectors</h2>
<h3 id="descendant-selectors">Descendant selectors</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h1</code></td>
<td><code>//h1</code></td>
<td><a href="#prefixes">?</a></td>
</tr>
<tr>
<td><code>div p</code></td>
<td><code>//div//p</code></td>
<td><a href="#axes">?</a></td>
</tr>
<tr>
<td><code>ul &gt; li</code></td>
<td><code>//ul/li</code></td>
<td><a href="#axes">?</a></td>
</tr>
<tr>
<td><code>ul &gt; li &gt; a</code></td>
<td><code>//ul/li/a</code></td>
<td></td>
</tr>
<tr>
<td><code>div &gt; *</code></td>
<td><code>//div/*</code></td>
<td></td>
</tr>
<tr>
<td>----</td>
<td>----</td>
<td>--</td>
</tr>
<tr>
<td><code>:root</code></td>
<td><code>/</code></td>
<td><a href="#prefixes">?</a></td>
</tr>
<tr>
<td><code>:root &gt; body</code></td>
<td><code>/body</code></td>
</tr>
</tbody>
</table>
<h3 id="attribute-selectors">Attribute selectors</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#id</code></td>
<td><code>//*[@id=&quot;id&quot;]</code></td>
<td><a href="#predicates">?</a></td>
</tr>
<tr>
<td><code>.class</code></td>
<td><code>//*[@class=&quot;class&quot;]</code> <em>...<a href="#class-check">kinda</a></em></td>
<td></td>
</tr>
<tr>
<td><code>input[type=&quot;submit&quot;]</code></td>
<td><code>//input[@type=&quot;submit&quot;]</code></td>
<td></td>
</tr>
<tr>
<td><code>a#abc[for=&quot;xyz&quot;]</code></td>
<td><code>//a[@id=&quot;abc&quot;][@for=&quot;xyz&quot;]</code></td>
<td><a href="#chaining-order">?</a></td>
</tr>
<tr>
<td><code>a[rel]</code></td>
<td><code>//a[@rel]</code></td>
<td></td>
</tr>
<tr>
<td>----</td>
<td>----</td>
<td>--</td>
</tr>
<tr>
<td><code>a[href^=&#39;/&#39;]</code></td>
<td><code>//a[starts-with(@href, &#39;/&#39;)]</code></td>
<td><a href="#string-functions">?</a></td>
</tr>
<tr>
<td><code>a[href$=&#39;pdf&#39;]</code></td>
<td><code>//a[ends-with(@href, &#39;.pdf&#39;)]</code></td>
<td></td>
</tr>
<tr>
<td><code>a[href*=&#39;://&#39;]</code></td>
<td><code>//a[contains(@href, &#39;://&#39;)]</code></td>
<td></td>
</tr>
<tr>
<td><code>a[rel~=&#39;help&#39;]</code></td>
<td><code>//a[contains(@rel, &#39;help&#39;)]</code> <em>...<a href="#class-check">kinda</a></em></td>
</tr>
</tbody>
</table>
<h3 id="order-selectors">Order selectors</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ul &gt; li:first-of-type</code></td>
<td><code>//ul/li[1]</code></td>
<td><a href="#indexing">?</a></td>
</tr>
<tr>
<td><code>ul &gt; li:nth-of-type(2)</code></td>
<td><code>//ul/li[2]</code></td>
<td></td>
</tr>
<tr>
<td><code>ul &gt; li:last-of-type</code></td>
<td><code>//ul/li[last()]</code></td>
<td></td>
</tr>
<tr>
<td><code>li#id:first-of-type</code></td>
<td><code>//li[1][@id=&quot;id&quot;]</code></td>
<td><a href="#chaining-order">?</a></td>
</tr>
<tr>
<td><code>a:first-child</code></td>
<td><code>//*[1][name()=&quot;a&quot;]</code></td>
<td></td>
</tr>
<tr>
<td><code>a:last-child</code></td>
<td><code>//*[last()][name()=&quot;a&quot;]</code></td>
</tr>
</tbody>
</table>
<h3 id="siblings">Siblings</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h1 ~ ul</code></td>
<td><code>//h1/following-sibling::ul</code></td>
<td><a href="#using-axes">?</a></td>
</tr>
<tr>
<td><code>h1 + ul</code></td>
<td><code>//h1/following-sibling::ul[1]</code></td>
<td></td>
</tr>
<tr>
<td><code>h1 ~ #id</code></td>
<td><code>//h1/following-sibling::[@id=&quot;id&quot;]</code></td>
</tr>
</tbody>
</table>
<h3 id="jquery">jQuery</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$(&#39;ul &gt; li&#39;).parent()</code></td>
<td><code>//ul/li/..</code></td>
<td><a href="#other-axes">?</a></td>
</tr>
<tr>
<td><code>$(&#39;li&#39;).closest(&#39;section&#39;)</code></td>
<td><code>//li/ancestor-or-self::section</code></td>
<td></td>
</tr>
<tr>
<td><code>$(&#39;a&#39;).attr(&#39;href&#39;)</code></td>
<td><code>//a/@href</code></td>
<td><a href="#steps">?</a></td>
</tr>
<tr>
<td><code>$(&#39;span&#39;).text()</code></td>
<td><code>//span/text()</code></td>
</tr>
</tbody>
</table>
<h3 id="other-things">Other things</h3>

<table>
<thead>
<tr>
<th>CSS</th>
<th>Xpath</th>
<th>?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h1:not([id])</code></td>
<td><code>//h1[not(@id)]</code></td>
<td><a href="#boolean-functions">?</a></td>
</tr>
<tr>
<td>Text match</td>
<td><code>//button[text()=&quot;Submit&quot;]</code></td>
<td><a href="#operators">?</a></td>
</tr>
<tr>
<td>Text match (substring)</td>
<td><code>//button[contains(text(),&quot;Go&quot;)]</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>//product[@price &gt; 2.50]</code></td>
<td></td>
</tr>
<tr>
<td>Has children</td>
<td><code>//ul[*]</code></td>
<td></td>
</tr>
<tr>
<td>Has children (specific)</td>
<td><code>//ul[li]</code></td>
<td></td>
</tr>
<tr>
<td>Or logic</td>
<td><code>//a[@name or @href]</code></td>
<td><a href="#operators">?</a></td>
</tr>
<tr>
<td>Union (joins results)</td>
<td>`//a</td>
<td>//div`</td>
<td><a href="#unions">?</a></td>
</tr>
</tbody>
</table>
<style>
/* ensure tables align */
table.xp {table-layout: fixed;}
table.xp tr>:nth-child(1) {width: 35%;}
table.xp tr>:nth-child(2) {width: auto;}
table.xp tr>:nth-child(3) {width: 10%; text-align:right;}
</style>

<h3 id="class-check">Class check</h3>

<pre><code class="bash">//div[contains(concat(<span class="hljs-string">&#x27; &#x27;</span>,normalize-space(@class),<span class="hljs-string">&#x27; &#x27;</span>),<span class="hljs-string">&#x27; foobar &#x27;</span>)]
</code></pre>
<p>Xpath doesn&#39;t have the &quot;check if part of space-separated list&quot; operator, so this is the workaround (<a href="http://pivotallabs.com/xpath-css-class-matching/">source</a>).</p>
<h2 id="expressions">Expressions</h2>
<h3 id="steps-and-axes">Steps and axes</h3>
<p>| <code>//</code> | <code>ul</code> | <code>/</code>  | <code>a[@id=&#39;link&#39;]</code> |
| Axis | Step | Axis | Step            |</p>
<h3 id="prefixes">Prefixes</h3>

<table>
<thead>
<tr>
<th>Prefix</th>
<th>Example</th>
<th>What</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//</code></td>
<td><code>//hr[@class=&#39;edge&#39;]</code></td>
<td>Anywhere</td>
</tr>
<tr>
<td><code>./</code></td>
<td><code>./a</code></td>
<td>Relative</td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>/html/body/div</code></td>
<td>Root</td>
</tr>
</tbody>
</table>
<p>Begin your expression with any of these.</p>
<h3 id="axes">Axes</h3>

<table>
<thead>
<tr>
<th>Axis</th>
<th>Example</th>
<th>What</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code></td>
<td><code>//ul/li/a</code></td>
<td>Child</td>
</tr>
<tr>
<td><code>//</code></td>
<td><code>//[@id=&quot;list&quot;]//a</code></td>
<td>Descendant</td>
</tr>
</tbody>
</table>
<p>Separate your steps with <code>/</code>. Use two (<code>//</code>) if you don&#39;t want to select direct children.</p>
<h3 id="steps">Steps</h3>

<pre><code class="bash">//div
//div[@name=<span class="hljs-string">&#x27;box&#x27;</span>]
//[@id=<span class="hljs-string">&#x27;link&#x27;</span>]
</code></pre>
<p>A step may have an element name (<code>div</code>) and <a href="#predicate">predicates</a> (<code>[...]</code>). Both are optional.
They can also be these other things:</p>

<pre><code class="bash">//a/text()     <span class="hljs-comment">#=&gt; &quot;Go home&quot;</span>
//a/@href      <span class="hljs-comment">#=&gt; &quot;index.html&quot;</span>
//a/*          <span class="hljs-comment">#=&gt; All a&#x27;s child elements</span>
</code></pre>
<h2 id="predicates">Predicates</h2>
<h3 id="predicates">Predicates</h3>

<pre><code class="bash">//div[<span class="hljs-literal">true</span>()]
//div[@class=<span class="hljs-string">&quot;head&quot;</span>]
//div[@class=<span class="hljs-string">&quot;head&quot;</span>][@id=<span class="hljs-string">&quot;top&quot;</span>]
</code></pre>
<p>Restricts a nodeset only if some condition is true. They can be chained.</p>
<h3 id="operators">Operators</h3>

<pre><code class="bash"><span class="hljs-comment"># Comparison</span>
//a[@id = <span class="hljs-string">&quot;xyz&quot;</span>]
//a[@id != <span class="hljs-string">&quot;xyz&quot;</span>]
//a[@price &gt; 25]
</code></pre>

<pre><code class="bash"><span class="hljs-comment"># Logic (and/or)</span>
//div[@id=<span class="hljs-string">&quot;head&quot;</span> and position()=2]
//div[(x and y) or not(z)]
</code></pre>
<p>Use comparison and logic operators to make conditionals.</p>
<h3 id="using-nodes">Using nodes</h3>

<pre><code class="bash"><span class="hljs-comment"># Use them inside functions</span>
//ul[count(li) &gt; 2]
//ul[count(li[@class=<span class="hljs-string">&#x27;hide&#x27;</span>]) &gt; 0]
</code></pre>

<pre><code class="bash"><span class="hljs-comment"># This returns `&lt;ul&gt;` that has a `&lt;li&gt;` child</span>
//ul[li]
</code></pre>
<p>You can use nodes inside predicates.</p>
<h3 id="indexing">Indexing</h3>

<pre><code class="bash">//a[1]                  <span class="hljs-comment"># first &lt;a&gt;</span>
//a[last()]             <span class="hljs-comment"># last &lt;a&gt;</span>
//ol/li[2]              <span class="hljs-comment"># second &lt;li&gt;</span>
//ol/li[position()=2]   <span class="hljs-comment"># same as above</span>
//ol/li[position()&gt;1]   <span class="hljs-comment"># :not(:first-of-type)</span>
</code></pre>
<p>Use <code>[]</code> with a number, or <code>last()</code> or <code>position()</code>.</p>
<h3 id="chaining-order">Chaining order</h3>

<pre><code class="bash">a[1][@href=<span class="hljs-string">&#x27;/&#x27;</span>]
a[@href=<span class="hljs-string">&#x27;/&#x27;</span>][1]
</code></pre>
<p>Order is significant, these two are different.</p>
<h3 id="nesting-predicates">Nesting predicates</h3>

<pre><code><span class="hljs-regexp">//</span>section[.<span class="hljs-regexp">//</span>h1[@id=<span class="hljs-string">&#x27;hi&#x27;</span>]]
</code></pre>
<p>This returns <code>&lt;section&gt;</code> if it has an <code>&lt;h1&gt;</code> descendant with <code>id=&#39;hi&#39;</code>.</p>
<h2 id="functions">Functions</h2>
<h3 id="node-functions">Node functions</h3>

<pre><code class="bash">name()                     <span class="hljs-comment"># //[starts-with(name(), &#x27;h&#x27;)]</span>
text()                     <span class="hljs-comment"># //button[text()=&quot;Submit&quot;]</span>
                           <span class="hljs-comment"># //button/text()</span>
lang(str)
namespace-uri()
</code></pre>

<pre><code class="bash">count()                    <span class="hljs-comment"># //table[count(tr)=1]</span>
position()                 <span class="hljs-comment"># //ol/li[position()=2]</span>
</code></pre>
<h3 id="boolean-functions">Boolean functions</h3>

<pre><code class="bash">not(expr)                  <span class="hljs-comment"># button[not(starts-with(text(),&quot;Submit&quot;))]</span>
</code></pre>
<h3 id="string-functions">String functions</h3>

<pre><code class="bash">contains()                 <span class="hljs-comment"># font[contains(@class,&quot;head&quot;)]</span>
starts-with()              <span class="hljs-comment"># font[starts-with(@class,&quot;head&quot;)]</span>
ends-with()                <span class="hljs-comment"># font[ends-with(@class,&quot;head&quot;)]</span>
</code></pre>

<pre><code class="bash">concat(x,y)
substring(str, start, len)
substring-before(<span class="hljs-string">&quot;01/02&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)  <span class="hljs-comment">#=&gt; 01</span>
substring-after(<span class="hljs-string">&quot;01/02&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)   <span class="hljs-comment">#=&gt; 02</span>
translate()
normalize-space()
string-length()
</code></pre>
<h3 id="type-conversion">Type conversion</h3>

<pre><code class="bash">string()
number()
boolean()
</code></pre>
<h2 id="axes">Axes</h2>
<h3 id="using-axes">Using axes</h3>

<pre><code class="bash">//ul/li                       <span class="hljs-comment"># ul &gt; li</span>
//ul/child::li                <span class="hljs-comment"># ul &gt; li (same)</span>
//ul/following-sibling::li    <span class="hljs-comment"># ul ~ li</span>
//ul/descendant-or-self::li   <span class="hljs-comment"># ul li</span>
//ul/ancestor-or-self::li     <span class="hljs-comment"># $(&#x27;ul&#x27;).closest(&#x27;li&#x27;)</span>
</code></pre>
<p>Steps of an expression are separated by <code>/</code>, usually used to pick child nodes. That&#39;s not always true: you can specify a different &quot;axis&quot; with <code>::</code>.</p>
<p>| <code>//</code> | <code>ul</code> | <code>/child::</code> | <code>li</code> |
| Axis | Step | Axis       | Step |</p>
<h3 id="child-axis">Child axis</h3>

<pre><code class="bash"><span class="hljs-comment"># both the same</span>
//ul/li/a
//child::ul/child::li/child::a
</code></pre>
<p><code>child::</code> is the default axis. This makes <code>//a/b/c</code> work.</p>

<pre><code class="bash"><span class="hljs-comment"># both the same</span>
<span class="hljs-comment"># this works because `child::li` is truthy, so the predicate succeeds</span>
//ul[li]
//ul[child::li]
</code></pre>

<pre><code class="bash"><span class="hljs-comment"># both the same</span>
//ul[count(li) &gt; 2]
//ul[count(child::li) &gt; 2]
</code></pre>
<h3 id="descendant-or-self-axis">Descendant-or-self axis</h3>

<pre><code class="bash"><span class="hljs-comment"># both the same</span>
//div//h4
//div/descendant-or-self::h4
</code></pre>
<p><code>//</code> is short for the <code>descendant-or-self::</code> axis.</p>

<pre><code class="bash"><span class="hljs-comment"># both the same</span>
//ul//[last()]
//ul/descendant-or-self::[last()]
</code></pre>
<h3 id="other-axes">Other axes</h3>

<table>
<thead>
<tr>
<th>Axis</th>
<th>Abbrev</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ancestor</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ancestor-or-self</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><code>attribute</code></td>
<td><code>@</code></td>
<td><code>@href</code> is short for <code>attribute::href</code></td>
</tr>
<tr>
<td><code>child</code></td>
<td></td>
<td><code>div</code> is short for <code>child::div</code></td>
</tr>
<tr>
<td><code>descendant</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>descendant-or-self</code></td>
<td><code>//</code></td>
<td><code>//</code> is short for <code>/descendant-or-self::node()/</code></td>
</tr>
<tr>
<td><code>namespace</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><code>self</code></td>
<td><code>.</code></td>
<td><code>.</code> is short for <code>self::node()</code></td>
</tr>
<tr>
<td><code>parent</code></td>
<td><code>..</code></td>
<td><code>..</code> is short for <code>parent::node()</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><code>following</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>following-sibling</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>preceding</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>preceding-sibling</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are other axes you can use.</p>
<h3 id="unions">Unions</h3>

<pre><code class="bash">//a | //span
</code></pre>
<p>Use <code>|</code> to join two expressions.</p>
<h2 id="more-examples">More examples</h2>
<h3 id="examples">Examples</h3>

<pre><code class="bash">//*                 <span class="hljs-comment"># all elements</span>
count(//*)          <span class="hljs-comment"># count all elements</span>
(//h1)[1]/text()    <span class="hljs-comment"># text of the first h1 heading</span>
//li[span]          <span class="hljs-comment"># find a &lt;li&gt; with an &lt;span&gt; inside it</span>
                    <span class="hljs-comment"># ...expands to //li[child::span]</span>
//ul/li/..          <span class="hljs-comment"># use .. to select a parent</span>
</code></pre>
<h3 id="find-a-parent">Find a parent</h3>

<pre><code class="bash">//section[h1[@id=<span class="hljs-string">&#x27;section-name&#x27;</span>]]
</code></pre>
<p>Finds a <code>&lt;section&gt;</code> that directly contains <code>h1#section-name</code></p>

<pre><code class="bash">//section[//h1[@id=<span class="hljs-string">&#x27;section-name&#x27;</span>]]
</code></pre>
<p>Finds a <code>&lt;section&gt;</code> that contains <code>h1#section-name</code>.
(Same as above, but uses descendant-or-self instead of child)</p>
<h3 id="closest">Closest</h3>

<pre><code class="bash">./ancestor-or-self::[@class=<span class="hljs-string">&quot;box&quot;</span>]
</code></pre>
<p>Works like jQuery&#39;s <code>$().closest(&#39;.box&#39;)</code>.</p>
<h3 id="attributes">Attributes</h3>

<pre><code class="bash">//item[@price &gt; 2*@discount]
</code></pre>
<p>Finds <code>&lt;item&gt;</code> and check its attributes</p>
<h2 id="references">References</h2>

<ul>
<li><a href="http://www.whitebeam.org/library/guide/TechNotes/xpathtestbed.rhtm">Xpath test bed</a> <em>(whitebeam.org)</em></li>
</ul>

</div>
</body>  
</html>